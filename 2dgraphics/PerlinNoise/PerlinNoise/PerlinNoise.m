//
//  PerlinNoise.m
//  PerlinNoise
//
//  Created by Jon Manning on 6/03/2014.
//  Copyright (c) 2014 Secret Lab. All rights reserved.
//

#import "PerlinNoise.h"

static PerlinNoise* _sharedNoise = nil;

@implementation PerlinNoise

// Returns the shared 'noise' object.
+ (PerlinNoise*) noise {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _sharedNoise = [[PerlinNoise alloc] init];
    });
    
    return _sharedNoise;
}

// Interpolates from one value to the next, using the cosine
// function to smooth the values.
- (float) interpolateCosineWithStart:(float)start 
                                 end:(float)end 
                              amount:(float)amount {
    
    // Perform cosine interpolation, which creates a smooth transition from one
    // value to the next
    
    float ft = amount * M_PI;
    
    float f = (1 - cosf(ft)) * 0.5f;
    
    return start * (1 - f) + end * f;
}

// Returns a random number generated by combining the components of
// the position and the random seed.
// This random number generator is guaranteed to provide the same 
// results for the same inputs.
- (float) noiseAtPosition:(CGPoint)position seed:(int)seed {
    
    
    int n = (int)position.x + (int)position.y * 57 * (seed * 131);
    n = (n<<13) ^ n;
    return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) 
        / 1073741824.0);
    
}

// Given a position, return the noise value at that position based on the noise
// values of its neighbours.
- (float) smoothNoiseAtPosition:(CGPoint)position seed:(int)seed {
    
    // Get the noise values for points at the corners...
    float topLeftCorner     = [self noiseAtPosition:(CGPoint){position.x-1, 
                                                              position.y - 1} seed:seed];
    float topRightCorner    = [self noiseAtPosition:(CGPoint){position.x+1, 
                                                              position.y - 1} seed:seed];
    float bottomLeftCorner  = [self noiseAtPosition:(CGPoint){position.x-1, 
                                                              position.y + 1} seed:seed];
    float bottomRightCorner = [self noiseAtPosition:(CGPoint){position.x+1, 
                                                              position.y + 1} seed:seed];
    
    // ... the sides...
    float leftSide   = [self noiseAtPosition:(CGPoint){position.x - 1, 
                                                       position.y} seed:seed];
    float rightSide  = [self noiseAtPosition:(CGPoint){position.x + 1, 
                                                       position.y} seed:seed];
    float topSide    = [self noiseAtPosition:(CGPoint){position.x, 
                                                       position.y - 1} seed:seed];
    float bottomSide = [self noiseAtPosition:(CGPoint){position.x, 
                                                       position.y + 1} seed:seed];
    
    // ... and the center.
    float center = [self noiseAtPosition:(CGPoint){position.x, position.y} seed:seed];
    
    // Merge them all together. The corners affect the result the least, the
    // center the most, and the sides halfway between.
    float corners = (topLeftCorner + topRightCorner + 
                     bottomLeftCorner + bottomRightCorner) / 16.0f;
    float sides = (leftSide + rightSide + topSide + bottomSide) / 8.0f;
    center = center / 4.0f;
    
    // Return the result.
    return corners + sides + center;
    
}

// Given a position in the image, work out how the noise values blend together
// in the image
- (float) interpolatedNoiseAtPosition:(CGPoint)position seed:(int)seed {
    int integralX = (int)position.x;
    int integralY = (int)position.y;
    
    float fractionalX = position.x - integralX;
    float fractionalY = position.y - integralY;
    
    float v1 = [self smoothNoiseAtPosition:(CGPoint){integralX, integralY} 
                                      seed:seed];
    float v2 = [self smoothNoiseAtPosition:(CGPoint){integralX+1, integralY} 
                                      seed:seed];
    float v3 = [self smoothNoiseAtPosition:(CGPoint){integralX, integralY+1} 
                                      seed:seed];
    float v4 = [self smoothNoiseAtPosition:(CGPoint){integralX+1, integralY+1} 
                                      seed:seed];
    
    float i1 = [self interpolateCosineWithStart:v1 end:v2 amount:fractionalX];
    float i2 = [self interpolateCosineWithStart:v3 end:v4 amount:fractionalX];
    
    return [self interpolateCosineWithStart:i1 end:i2 amount:fractionalY];
    
}

// Calculate the value of the image at a given position by applying 
// Perlin noise.
- (float) perlinNoiseAtPosition:(CGPoint)position persistence:(float)persistence 
          octaves:(int)octaves seed:(int)seed {
    
    float total = 0.0;
    
    for (int i = 0; i <= octaves - 1; i++) {
        
        int frequency = pow(2, i);
        float amplitude = pow(persistence, i);
        
        total += [self interpolatedNoiseAtPosition:(CGPoint){(position.x * frequency), 
                                                             (position.y * frequency)} 
                                                             seed:seed * (i+1)] * amplitude;
        
    }
    
    return total;
    
}

// Generate an image filled with Perlin noise.
- (void) imageWithSize:(CGSize)size persistence:(float)persistence 
         octaves:(int)octaves seed:(int) seed 
         completion:(void (^)(UIImage* image))completionBlock {
    
    // If we don't have a completion block, immediately return
    // after logging an error.
    if (completionBlock == NULL) {
        NSLog(@"Error: %@ was called with no completion block, so there's no way to return the image. Provide a completion block.", NSStringFromSelector(_cmd));
        return;
    }
    
    // Create a background queue to run the operation on
    NSOperationQueue* backgroundQueue = [[NSOperationQueue alloc] init];
    
    // Run the work in the background
    [backgroundQueue addOperationWithBlock:^{
        
        // Begin a new graphics context
        UIGraphicsBeginImageContextWithOptions(size, YES, [UIScreen mainScreen].scale);
        
        // Get the graphics context as a CGContextRef
        // so that we can use CoreGraphics calls later
        CGContextRef context =  UIGraphicsGetCurrentContext();
        
        // For each pixel in the image, work out the value using the Perlin
        // noise algorithm.
        for (int x = 0; x <= size.width; x+= 1) {
            
            for (int y = 0; y <= size.height; y += 1) {
                
                // Work out the Perlin noise value
                // for this pixel.
                float value = [self perlinNoiseAtPosition:(CGPoint){x / size.width, 
                    y / size.height} persistence:persistence octaves:octaves seed:seed];
                
                // Example of banding the output (uncomment to apply)
                /*
                if (value > 0.5)
                    value = 0.9;
                else if (value > 0.3)
                    value = 0.5;
                else if (value > 0.2)
                    value = 0.3;
                else
                    value = 0.2;
                 */
                
                // Once we have the value, we turn that into a grayscale color...
                CGContextSetGrayFillColor(context, value, 1.0);
                
                // ...and fill the appropriate pixel.
                CGRect rect = CGRectMake(x, y, x+1, y+1);
                CGContextFillRect(context, rect);
                
            }
            
        }
        
        // Once the rendering is done, grab the image from the context
        UIImage* image = UIGraphicsGetImageFromCurrentImageContext();
        
        // And then call the completion block, making sure
        // to do it on the main queue
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            completionBlock(image);
        }];
        
        // Finally, tidy up by removing the image context
        // we created.
        UIGraphicsEndImageContext();
        
    }];
    
    // We don't return anything in this method, because the
    // image is returned to the caller via the completion
    // block.
}

@end
